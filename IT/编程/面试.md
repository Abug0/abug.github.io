## Python

is和==区别

弱引用

await和async

asyncio.sleep和sleep

 magic method

dummy

GIL

闭包

super与MRO

迭代器 可迭代对象  生成器

int long 整数长度问题

bytes unicode utf8

import 原理

静态变量（类变量）与实例变量

* 

staticmethod与classmethod

* 

上下文管理器

* \__enter__
* \__exit__

## 操作系统

进程 线程 协程

同步 异步 阻塞  非阻塞

进程空间模型

虚拟内存

io多路复用

* select
* poll
* epoll

## 数据库

删除表

事务、隔离级别

默认级别

B+树

B树与B+树

联合索引

死锁

主键索引与唯一索引

索引失效

* 不符合最左前缀原则：like或者复合索引
* 等号右边使用了函数或者隐式类型转换
* 

## 网络

GET与POST

## 算法

大顶堆的插入删除

## Redis

* 缓存击穿：某个热点key失效，大量请求到达数据库
  * 过期时间：永不过期
  * 锁：拿到锁才可以访问数据库
* 缓存雪崩：大量key失效，大量请求到达数据库
  * 过期时间加一个随机值，防止同一时刻过期
  * 防止redis宕机：主从
  * 熔断、限流
* 缓存穿透：查询一个不存在的数据，请求直接到达数据库
  * 缓存null
  * 布隆过滤器

scan命令使用

RDB与AOF

大key问题以及value大小限制

* key对应的value过大
* redis限制string类型不超过512m，实践建议10KB一下
* hash、list、set、zset元素个数不要超过5000

key过期发生什么

key过长发生什么

> * 非常长的key是不推荐的。一个1024 bytes是一个非常坏的注意，不仅仅是因为内存浪费，更是因为在数据集中搜索对比的时候需要耗费更多的成本。当要处理的是匹配一个非常大的值，从内存和带宽的角度来看，使用这个值的hash值是更好的办法（比如使用SHA1）。
> * 特别短的key通常也是不推荐的。在写像u100flw这样的键的时候，有一个小小的要点，我们可以用user:1000:followers代替。可读性更好，对于key对象和value对象增加的空间占用与此相比来说倒是次要的。当短的key可以很明显减少空间占用的时候，你的工作就是找到正确的平衡。
> * 尝试去固定一个schema。比如object-type:id是一个好主意，-和.通常用于多个字符的域，就像comment:1234:reply.to，或者comment:1234:reply-to。
> * 最大的key允许512MB。



## 系统

rpc与http的区别和联系

rpc的使用场景

restful的理解

DNS和HTTPS过程

幂等

* GET/PUT/DELETE 幂等
* POST/PATCH 非幂等

正则表达式的实现

访问微博背后的过程？

微博赞/评论系统设计？

性能排查和优化思路？

七天阅读量排行榜设计？

bug的排查思路？

限流

## 底层原理

float的实现







面向对象六原则

* 单一职责
  * 引起类变化的因素应当尽可能少
* 里氏替换
  * 父类出现的地方可以用子类代替
  * 子类出现的地方不一定可以用父类代替
* 依赖倒转
  * 高层模块不依赖底层模块，两者都依赖抽象（模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系）
  * 抽象（接口或者抽象类）不应该依赖细节（实现类）
  * 细节应该依赖于抽象
* 接口隔离
  * 避免接口的过度臃肿
* 迪米特（最少知识原则）
  * 一个对象对其他对象应该有最少的了解：调用者只需要知道被调用者的出参和入参定义，而无需对其内部实现做任何假设。
  * 只和朋友类交流：尽可能少的引用其他类，只和成员类或者出现在参数中的类交流。
* 开闭
  * 对扩展开放，对修改关闭。



REST的认识：

* 客户端-服务器：组件分离，可以相对各自独立的演化
* 缓存：减少交互次数
* 分层
* 无状态：每个请求不依赖于其他请求，各请求间相互独立，每次请求由客户端将完成请求需要的全部信息传给服务端
  * 登录：token或者cookie，基本都需要预先完成登录操作，无法做到完全的无状态
  * 非登录：例如，"下一页"请求，一种做法是服务端保存当前页码，请求到达的时候查看对应的下一页页码，另一种做法是客户端请求中将对应的页码带上，不需要服务端记住当前访问到了哪一页，也就是不需要服务端保存上下文。第二种做法即是无状态的。
* 接口统一，get/post/put/delete，uri标识资源
* 超文本驱动（HATEOAS）

## 参考

[[1] 一步一步教你认识Python闭包](https://foofish.net/python-closure.html)

[REST论文中文版](https://github.com/Abug0/abug0.github.io/blob/master/IT/books/REST_cn.pdf)

[Restful架构的理解及使用场景分析](https://kricen.github.io/2018/03/05/perday/restful/)

[理论与实例，准确理解REST的无状态设计](https://blog.csdn.net/matthew_zhang/article/details/63410421)

[怎样用通俗的语言解释REST，以及RESTful？](https://www.zhihu.com/question/28557115)

[服务架构演进史](http://icyfenix.cn/architecture/architect-history/)

[REST设计风格](http://icyfenix.cn/architect-perspective/general-architecture/api-style/rest.html)

[REST APIs must be hypertext-driven](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)

[面向对象设计之魂的六大原则](https://zhuanlan.zhihu.com/p/58092071)

[面向对象之六大设计原则](https://segmentfault.com/a/1190000020182270)

[Python中下划线的5种含义](https://zhuanlan.zhihu.com/p/36173202)

[索引失效原理，终于有人讲明白了](https://cloud.tencent.com/developer/article/1704743)

[RPC与HTTP](https://www.jianshu.com/p/fe5ccfc5d7bd)

[你猜一个 TCP 连接上面能发多少个 HTTP 请求](https://zhuanlan.zhihu.com/p/61423830)

[彻底理解同步 异步 阻塞 非阻塞](https://www.cnblogs.com/loveer/p/11479249.html)

[彻底理解 IO 多路复用实现机制](https://juejin.cn/post/6882984260672847879)
