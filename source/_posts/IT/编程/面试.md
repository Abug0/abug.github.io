## Python

is和==区别

弱引用

await和async

asyncio.sleep和sleep

 magic method



dummy

GIL:

* 存在原因：内存管理的线程安全

闭包

super与MRO

迭代器 可迭代对象  生成器

深拷贝与浅拷贝

垃圾回收

int long 整数长度问题

bytes unicode utf8

import 原理

新式类与旧式类

列表推导式的好处

内存泄漏

* 全局的list、dict或其他容器对象，向里面插入对象没有删除
* 引用循环，且循环引用的对象定义了\__del__方法

可变对象的内存泄露

静态变量（类变量）与实例变量

* 

staticmethod与classmethod

* 

上下文管理器

* \__enter__
* \__exit__

字典一样访问一个类

```python
class A:
    def __init__(self) -> None:
        self.a = 123
        self.b = 56

    def __getitem__(self, item):
        return getattr(self, item)

    def __setitem__(self, item, value):
        setattr(self, item, value)

    def __delitem__(self, item):
        delattr(self, item)


a = A()
print(a.a)
print(a['a'])

a.c = 78
print(a.__dict__)
print(a.c)
print(a['c'])

a['d'] = 100
print(a.__dict__)
print(a.d)
print(a['d'])
print(dir(a))

del a.d
print(dir(a))

```



## 操作系统

进程 线程 协程

同步 异步 阻塞  非阻塞

进程空间模型

虚拟内存

io多路复用

* select
* poll
* epoll

## 数据库

删除表

事务、隔离级别

默认级别

B+树

B树与B+树

联合索引

死锁

主键索引与唯一索引

覆盖索引 前缀索引

自增ID与UUID区别

索引失效

* 不符合最左前缀原则：like或者复合索引
* 等号右边使用了函数或者隐式类型转换

MyISAM和InnoDB区别：

* InnoDB支持事务，MyISAM不支持
* InnoDB聚簇索引，MyISAM非聚簇
* InnoDB不保存表的行数，MyISAM保存
* InnoDB行锁，MyISAM表锁
* InnoDB支持外键，MyISAM不支持

## 网络

GET与POST

Http2.0:

* 多路复用：多个请求并行发送
* 二进制分帧
* 支持头部压缩

## 算法

大顶堆的插入删除

## Kafka

如何保证消费的幂等性

## Redis

* 缓存击穿：某个热点key失效，大量请求到达数据库
  * 过期时间：永不过期
  * 锁：拿到锁才可以访问数据库
* 缓存雪崩：大量key失效，大量请求到达数据库
  * 过期时间加一个随机值，防止同一时刻过期
  * 防止redis宕机：主从
  * 熔断、限流
* 缓存穿透：查询一个不存在的数据，请求直接到达数据库
  * 缓存null
  * 布隆过滤器

scan命令使用

RDB与AOF

大key问题以及value大小限制

* key对应的value过大
* redis限制string类型不超过512m，实践建议10KB一下
* hash、list、set、zset元素个数不要超过5000

key过期发生什么

key过长发生什么

> * 非常长的key是不推荐的。一个1024 bytes是一个非常坏的注意，不仅仅是因为内存浪费，更是因为在数据集中搜索对比的时候需要耗费更多的成本。当要处理的是匹配一个非常大的值，从内存和带宽的角度来看，使用这个值的hash值是更好的办法（比如使用SHA1）。
> * 特别短的key通常也是不推荐的。在写像u100flw这样的键的时候，有一个小小的要点，我们可以用user:1000:followers代替。可读性更好，对于key对象和value对象增加的空间占用与此相比来说倒是次要的。当短的key可以很明显减少空间占用的时候，你的工作就是找到正确的平衡。
> * 尝试去固定一个schema。比如object-type:id是一个好主意，-和.通常用于多个字符的域，就像comment:1234:reply.to，或者comment:1234:reply-to。
> * 最大的key允许512MB。



## 系统

rpc与http的区别和联系

rpc的使用场景

restful的理解

DNS和HTTPS过程

幂等

* GET/PUT/DELETE 幂等
* POST/PATCH 非幂等

正则表达式的实现

访问微博背后的过程？

微博赞/评论系统设计？

性能排查和优化思路？

七天阅读量排行榜设计？

bug的排查思路？

限流

## 底层原理

float的实现



## Docker与K8s





面向对象六原则

* 单一职责
  * 引起类变化的因素应当尽可能少
* 里氏替换
  * 父类出现的地方可以用子类代替
  * 子类出现的地方不一定可以用父类代替
* 依赖倒转
  * 高层模块不依赖底层模块，两者都依赖抽象（模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系）
  * 抽象（接口或者抽象类）不应该依赖细节（实现类）
  * 细节应该依赖于抽象
* 接口隔离
  * 避免接口的过度臃肿
* 迪米特（最少知识原则）
  * 一个对象对其他对象应该有最少的了解：调用者只需要知道被调用者的出参和入参定义，而无需对其内部实现做任何假设。
  * 只和朋友类交流：尽可能少的引用其他类，只和成员类或者出现在参数中的类交流。
* 开闭
  * 对扩展开放，对修改关闭。



REST的认识：

* 客户端-服务器：组件分离，可以相对各自独立的演化
* 缓存：减少交互次数
* 分层
* 无状态：每个请求不依赖于其他请求，各请求间相互独立，每次请求由客户端将完成请求需要的全部信息传给服务端
  * 登录：token或者cookie，基本都需要预先完成登录操作，无法做到完全的无状态
  * 非登录：例如，"下一页"请求，一种做法是服务端保存当前页码，请求到达的时候查看对应的下一页页码，另一种做法是客户端请求中将对应的页码带上，不需要服务端记住当前访问到了哪一页，也就是不需要服务端保存上下文。第二种做法即是无状态的。
* 接口统一，get/post/put/delete，uri标识资源
* 超文本驱动（HATEOAS）

## 参考

[[1] 一步一步教你认识Python闭包](https://foofish.net/python-closure.html)

[REST论文中文版](https://github.com/Abug0/abug0.github.io/blob/master/IT/books/REST_cn.pdf)

[Restful架构的理解及使用场景分析](https://kricen.github.io/2018/03/05/perday/restful/)

[理论与实例，准确理解REST的无状态设计](https://blog.csdn.net/matthew_zhang/article/details/63410421)

[怎样用通俗的语言解释REST，以及RESTful？](https://www.zhihu.com/question/28557115)

[服务架构演进史](http://icyfenix.cn/architecture/architect-history/)

[REST设计风格](http://icyfenix.cn/architect-perspective/general-architecture/api-style/rest.html)

[REST APIs must be hypertext-driven](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)

[面向对象设计之魂的六大原则](https://zhuanlan.zhihu.com/p/58092071)

[面向对象之六大设计原则](https://segmentfault.com/a/1190000020182270)

[Python中下划线的5种含义](https://zhuanlan.zhihu.com/p/36173202)

[索引失效原理，终于有人讲明白了](https://cloud.tencent.com/developer/article/1704743)

[RPC与HTTP](https://www.jianshu.com/p/fe5ccfc5d7bd)

[你猜一个 TCP 连接上面能发多少个 HTTP 请求](https://zhuanlan.zhihu.com/p/61423830)

[彻底理解同步 异步 阻塞 非阻塞](https://www.cnblogs.com/loveer/p/11479249.html)

[怎样理解阻塞非阻塞与同步异步的区别?](https://www.zhihu.com/question/19732473/answer/241673170)

[深入理解一下“同步IO和异步 IO，阻塞 IO和非阻塞IO”](https://blog.51cto.com/u_15163980/2699646)

[socket的可读可写事件](https://www.cnblogs.com/my_life/articles/10910375.html)

[彻底理解 IO 多路复用实现机制](https://juejin.cn/post/6882984260672847879)

[9.22 定义上下文管理器的简单方法](https://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p22_define_context_managers_the_easy_way.html)

[深入理解 Python 中的上下文管理器](https://juejin.cn/post/6844903795403522056)

[学习Python，怎能不懂点PEP呢？](https://mp.weixin.qq.com/s/oRoBxZ2-IyuPOf_MWyKZyw)

[Python 的上下文管理器是怎么设计的？](https://www.cnblogs.com/pythonista/p/15012794.html)

[redis缓存穿透，缓存击穿，缓存雪崩原因+解决方案](https://zhuanlan.zhihu.com/p/75588064)

[缓存穿透、缓存击穿、缓存雪崩，看这篇就够了](https://xie.infoq.cn/article/a035f12e5590385ac578778b0)

[为什么要设计GIL？](https://juejin.cn/post/6844903877054038023)

[遇到慢查询问题，可以这样思考与解决](https://www.diaosi.love/archives/%E9%81%87%E5%88%B0%E6%85%A2%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E6%80%9D%E8%80%83%E4%B8%8E%E8%A7%A3%E5%86%B3)

[Linux内核File cache机制（中篇）](https://www.modb.pro/db/87705)

[Kafka事务特性详解](jianshu.com/p/64c93065473e)

[Kafka Exactly Once和事务](http://dengchengchao.com/?p=1386)

[Kafka事务到底是什么意思？](https://www.zhihu.com/question/311885878)

[Python元组是不可变的，除非包含可变对象](https://python.freelycode.com/contribution/detail/1174)

[Python之内存泄漏和内存溢出](https://www.cnblogs.com/zzbj/p/13532156.html)

[Python 被导入模块多次被加载的问题（基于python的import机制）](https://blog.csdn.net/longzhiwen888/article/details/46604265)

[Python 的 import 究竟做了什么](https://re-ra.xyz/Python-%E7%9A%84-import-%E7%A9%B6%E7%AB%9F%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/#reference)

[MySQL联接查询算法（NLJ、BNL、BKA、HashJoin）](https://blog.csdn.net/joenqc/article/details/104094042)

[为什么 HTTP PATCH 方法不是幂等的及其延伸](https://juejin.cn/post/6844903813799739399)

[RFC7231: Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content ](https://greenbytes.de/tech/webdav/rfc7231.html#PUT)

